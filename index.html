<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Sacred Portrait</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: 'Georgia', serif; letter-spacing: 2px;
            pointer-events: none; transition: opacity 1s;
        }
        #scroll-hint {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-family: 'Georgia', serif;
            letter-spacing: 3px; font-size: 14px; pointer-events: none;
            animation: blink 3s infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Loading Experience...</div>
    <div id="scroll-hint">SCROLL TO ASCEND</div>

    <script type="module">
        import * as THREE from 'three';

        // --- 設定 ---
        const CONFIG = {
            scrollSpeed: 0.0005,    // スクロール感度
            inertia: 0.08,          // 慣性の強さ (小さいほどヌルヌル)
            maxScroll: 15,          // スクロールの長さ
            fogColor: 0x1a1a1a,     // 霧の色
            goldColor: 0xffd700,    // 金色の色味
            woodColor: 0x3d2314     // 木枠の色味
        };

        // --- シーン初期化 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.03); // 霧で奥行きを出す
        scene.background = new THREE.Color(0x050505); // 背景色

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // 影を有効化
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 映画のような色調
        document.body.appendChild(renderer.domElement);

        // --- ライティング (演出の要) ---
        // 1. 環境光 (全体をうっすら照らす)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // 2. スポットライト (絵画を劇的に照らす)
        const spotLight = new THREE.SpotLight(0xffaa55, 200);
        spotLight.position.set(5, 10, 10);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // 3. バックライト (シルエット用)
        const backLight = new THREE.DirectionalLight(0x6688ff, 2);
        backLight.position.set(-5, 5, -10);
        scene.add(backLight);

        // --- マテリアル定義 ---
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.goldColor,
            metalness: 1.0, // 完全な金属
            roughness: 0.3, // 少しざらつきを入れて光を拡散させる
        });

        const woodMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.woodColor,
            roughness: 0.9,
            metalness: 0.0
        });

        // --- オブジェクト構築 ---
        const groupPortrait = new THREE.Group();
        scene.add(groupPortrait);

        // 1. 絵画画像の読み込み
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('image.png', (texture) => {
            // 画像のアスペクト比に合わせてサイズ調整
            const aspect = texture.image.width / texture.image.height;
            const height = 5;
            const width = height * aspect;

            // 絵画本体
            const imgGeo = new THREE.PlaneGeometry(width, height);
            const imgMat = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.4
            });
            const painting = new THREE.Mesh(imgGeo, imgMat);
            painting.castShadow = true;
            painting.receiveShadow = true;
            groupPortrait.add(painting);

            // 額縁 (BoxGeometryで作成)
            // 内側の金枠
            const innerFrame = new THREE.Mesh(
                new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.2),
                goldMaterial
            );
            innerFrame.position.z = -0.1;
            innerFrame.castShadow = true;
            groupPortrait.add(innerFrame);

            // 外側の木枠
            const outerFrame = new THREE.Mesh(
                new THREE.BoxGeometry(width + 0.8, height + 0.8, 0.4),
                woodMaterial
            );
            outerFrame.position.z = -0.2;
            outerFrame.castShadow = true;
            groupPortrait.add(outerFrame);

            document.getElementById('loading').style.opacity = 0;
        });

        // 初期位置 (画面の下の方に隠しておく)
        groupPortrait.position.y = -10; 
        groupPortrait.rotation.x = 0.2; // 少し上を向かせる

        // 2. 遠くの城 (箱を組み合わせてプロシージャルに作成)
        const castleGroup = new THREE.Group();
        const castleMat = new THREE.MeshStandardMaterial({ color: 0x202020, roughness: 1 });
        
        // メインタワー
        const tower1 = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 2), castleMat);
        const tower2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 6, 1.5), castleMat);
        tower2.position.set(3, -1, 0);
        const wall = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 1), castleMat);
        wall.position.set(1.5, -2.5, 0);
        
        castleGroup.add(tower1, tower2, wall);
        castleGroup.position.set(5, -5, -20); // ずっと奥に配置
        scene.add(castleGroup);

        // 3. 草原 (地面)
        const groundGeo = new THREE.PlaneGeometry(100, 100, 32, 32);
        // 地形を少し波打たせる
        const pos = groundGeo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            pos.setZ(i, Math.random() * 0.5);
        }
        groundGeo.computeVertexNormals();
        
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x112205, 
            roughness: 0.8,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -8; // 絵画の下の初期位置よりさらに下
        ground.receiveShadow = true;
        scene.add(ground);

        // 4. 綿毛パーティクル
        const particleCount = 300;
        const particlesGeo = new THREE.BufferGeometry();
        const particlePositions = [];
        const particleSpeeds = [];

        for (let i = 0; i < particleCount; i++) {
            particlePositions.push(
                (Math.random() - 0.5) * 30, // X
                (Math.random() - 0.5) * 40, // Y
                (Math.random() - 0.5) * 20 + 5 // Z (手前中心)
            );
            particleSpeeds.push(Math.random() * 0.02 + 0.005);
        }
        particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
        
        // 綿毛のような柔らかいテクスチャをCanvasで生成
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const particleTexture = new THREE.CanvasTexture(canvas);

        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.3,
            map: particleTexture,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particlesGeo, particleMat);
        scene.add(particles);


        // --- インタラクション (スクロール制御) ---
        let scrollTarget = 0;
        let scrollCurrent = 0;

        // ホイールイベント
        window.addEventListener('wheel', (e) => {
            scrollTarget += e.deltaY * CONFIG.scrollSpeed;
            scrollTarget = Math.max(0, Math.min(scrollTarget, 1)); // 0〜1の範囲に制限
        });

        // タッチイベント（スマホ対応）
        let touchStartY = 0;
        window.addEventListener('touchstart', (e) => touchStartY = e.touches[0].clientY);
        window.addEventListener('touchmove', (e) => {
            const deltaY = touchStartY - e.touches[0].clientY;
            scrollTarget += deltaY * CONFIG.scrollSpeed * 2;
            scrollTarget = Math.max(0, Math.min(scrollTarget, 1));
            touchStartY = e.touches[0].clientY;
        });

        // --- アニメーションループ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 慣性スクロール処理
            // 現在値を目標値に徐々に近づける (Linear Interpolation)
            scrollCurrent += (scrollTarget - scrollCurrent) * CONFIG.inertia;

            // 2. カメラワーク
            // スクロール0: 地面近くを見る
            // スクロール1: 絵画の正面に上昇
            const scrollY = scrollCurrent * CONFIG.maxScroll;
            
            // カメラ位置: 下から上へ
            camera.position.y = -6 + (scrollY * 0.8); 
            camera.position.z = 8 - (scrollY * 0.2); // 少し近づく
            
            // 絵画位置: 少し浮き上がる演出
            groupPortrait.position.y = -5 + scrollY;
            // 角度: 最初は上向き、徐々に正面へ
            groupPortrait.rotation.x = 0.3 - (scrollCurrent * 0.3);

            // 3. 背景のパララックス
            castleGroup.position.y = -5 + (scrollY * 0.5); // 遠景はゆっくり動く

            // 4. パーティクルアニメーション
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                // Y座標を上昇させる
                positions[i * 3 + 1] += particleSpeeds[i] + (scrollCurrent * 0.1);
                
                // ループ処理
                if (positions[i * 3 + 1] > 15) {
                    positions[i *